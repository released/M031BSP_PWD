; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.EntryLowPower||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  EntryLowPower PROC
;;;76     
;;;77     void EntryLowPower(void)
000000  b510              PUSH     {r4,lr}
;;;78     {
;;;79     	printf("%s\r\n" , __FUNCTION__);
000002  4906              LDR      r1,|L1.28|
000004  a006              ADR      r0,|L1.32|
000006  f7fffffe          BL       __2printf
;;;80     
;;;81     	set_flag(flag_EnableLED , ENABLE);
00000a  4807              LDR      r0,|L1.40|
00000c  6841              LDR      r1,[r0,#4]  ; BitFlag
00000e  2201              MOVS     r2,#1
000010  4311              ORRS     r1,r1,r2
000012  6041              STR      r1,[r0,#4]  ; BitFlag
;;;82     
;;;83     	#if 0
;;;84         UART_WAIT_TX_EMPTY(UART0);
;;;85     	
;;;86         /* Configure all GPIO as Quasi-bidirectional Mode*/
;;;87         GPIO_SetMode(PA, GPIO_P0_TO_P15, GPIO_MODE_QUASI);
;;;88         GPIO_SetMode(PB, GPIO_P0_TO_P15, GPIO_MODE_QUASI);
;;;89         GPIO_SetMode(PC, GPIO_P0_TO_P15, GPIO_MODE_QUASI);
;;;90         GPIO_SetMode(PD, GPIO_P0_TO_P15, GPIO_MODE_QUASI);
;;;91         GPIO_SetMode(PE, GPIO_P0_TO_P15, GPIO_MODE_QUASI);
;;;92         GPIO_SetMode(PF, GPIO_P0_TO_P15, GPIO_MODE_QUASI);
;;;93     
;;;94         /* Unlock protected registers before entering Power-down mode */
;;;95         SYS_UnlockReg();
;;;96     
;;;97         /* LVR must be enabled and the POR will be enabled automatically */
;;;98         SYS_ENABLE_LVR();
;;;99         /* Turn off internal analog POR circuit */
;;;100        SYS_Disable_AnalogPORCircuit();
;;;101        /* Disable Power-on Reset */
;;;102        SYS_DISABLE_POR();
;;;103    
;;;104        UART_WAIT_TX_EMPTY(UART0);
;;;105    	CLK_PowerDown();
;;;106    
;;;107    	#else
;;;108    	CLK_Idle();
000014  f7fffffe          BL       CLK_Idle
;;;109    	#endif
;;;110    
;;;111    
;;;112    
;;;113    }
000018  bd10              POP      {r4,pc}
;;;114    
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      ||.constdata||
                  |L1.32|
000020  25730d0a          DCB      "%s\r\n",0
000024  00      
000025  00                DCB      0
000026  00                DCB      0
000027  00                DCB      0
                  |L1.40|
                          DCD      ||.data||

                          AREA ||i.GPABGH_IRQHandler||, CODE, READONLY, ALIGN=2

                  GPABGH_IRQHandler PROC
;;;133    
;;;134    void GPABGH_IRQHandler(void)
000000  b508              PUSH     {r3,lr}
;;;135    {
;;;136        volatile uint32_t temp;
;;;137    
;;;138        if(GPIO_GET_INT_FLAG(PA, BIT7))
000002  480a              LDR      r0,|L2.44|
000004  6a01              LDR      r1,[r0,#0x20]
000006  0609              LSLS     r1,r1,#24
000008  d508              BPL      |L2.28|
;;;139        {
;;;140            GPIO_CLR_INT_FLAG(PA, BIT7);
00000a  2180              MOVS     r1,#0x80
00000c  6201              STR      r1,[r0,#0x20]
;;;141    		set_flag(flag_EnableLED , DISABLE);		
00000e  4808              LDR      r0,|L2.48|
000010  6841              LDR      r1,[r0,#4]  ; BitFlag
000012  0849              LSRS     r1,r1,#1
000014  0049              LSLS     r1,r1,#1
000016  6041              STR      r1,[r0,#4]  ; BitFlag
;;;142            printf("PA.7 wake up\n");
000018  a006              ADR      r0,|L2.52|
00001a  e003              B        |L2.36|
                  |L2.28|
;;;143        }
;;;144        else
;;;145        {
;;;146            /* Un-expected interrupt. Just clear all PB interrupts */
;;;147            temp = PA->INTSRC;
00001c  6a01              LDR      r1,[r0,#0x20]
;;;148            PA->INTSRC = temp;
00001e  9100              STR      r1,[sp,#0]
000020  6201              STR      r1,[r0,#0x20]
;;;149            printf("Un-expected interrupts.\n");
000022  a008              ADR      r0,|L2.68|
                  |L2.36|
000024  f7fffffe          BL       __2printf
;;;150        }
;;;151    }
000028  bd08              POP      {r3,pc}
;;;152    
                          ENDP

00002a  0000              DCW      0x0000
                  |L2.44|
                          DCD      0x40004000
                  |L2.48|
                          DCD      ||.data||
                  |L2.52|
000034  50412e37          DCB      "PA.7 wake up\n",0
000038  2077616b
00003c  65207570
000040  0a00    
000042  00                DCB      0
000043  00                DCB      0
                  |L2.68|
000044  556e2d65          DCB      "Un-expected interrupts.\n",0
000048  78706563
00004c  74656420
000050  696e7465
000054  72727570
000058  74732e0a
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.GPCDEF_IRQHandler||, CODE, READONLY, ALIGN=2

                  GPCDEF_IRQHandler PROC
;;;114    
;;;115    void GPCDEF_IRQHandler(void)
000000  b508              PUSH     {r3,lr}
;;;116    {
;;;117        volatile uint32_t temp;
;;;118    
;;;119        if(GPIO_GET_INT_FLAG(PC, BIT3))
000002  480a              LDR      r0,|L3.44|
000004  6a01              LDR      r1,[r0,#0x20]
000006  0709              LSLS     r1,r1,#28
000008  d508              BPL      |L3.28|
;;;120        {
;;;121            GPIO_CLR_INT_FLAG(PC, BIT3);
00000a  2108              MOVS     r1,#8
00000c  6201              STR      r1,[r0,#0x20]
;;;122    		set_flag(flag_EnableLED , DISABLE);				
00000e  4808              LDR      r0,|L3.48|
000010  6841              LDR      r1,[r0,#4]  ; BitFlag
000012  0849              LSRS     r1,r1,#1
000014  0049              LSLS     r1,r1,#1
000016  6041              STR      r1,[r0,#4]  ; BitFlag
;;;123            printf("PC.3 wake up\n");
000018  a006              ADR      r0,|L3.52|
00001a  e003              B        |L3.36|
                  |L3.28|
;;;124        }
;;;125        else
;;;126        {
;;;127            /* Un-expected interrupt. Just clear all PB interrupts */
;;;128            temp = PC->INTSRC;
00001c  6a01              LDR      r1,[r0,#0x20]
;;;129            PC->INTSRC = temp;
00001e  9100              STR      r1,[sp,#0]
000020  6201              STR      r1,[r0,#0x20]
;;;130            printf("Un-expected interrupts.\n");
000022  a008              ADR      r0,|L3.68|
                  |L3.36|
000024  f7fffffe          BL       __2printf
;;;131        }
;;;132    }
000028  bd08              POP      {r3,pc}
;;;133    
                          ENDP

00002a  0000              DCW      0x0000
                  |L3.44|
                          DCD      0x40004080
                  |L3.48|
                          DCD      ||.data||
                  |L3.52|
000034  50432e33          DCB      "PC.3 wake up\n",0
000038  2077616b
00003c  65207570
000040  0a00    
000042  00                DCB      0
000043  00                DCB      0
                  |L3.68|
000044  556e2d65          DCB      "Un-expected interrupts.\n",0
000048  78706563
00004c  74656420
000050  696e7465
000054  72727570
000058  74732e0a
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.GPIO_Power_Init||, CODE, READONLY, ALIGN=2

                  GPIO_Power_Init PROC
;;;153    
;;;154    void GPIO_Power_Init (void)		// PB3 , to entry low power mode
000000  b510              PUSH     {r4,lr}
;;;155    {
;;;156        GPIO_SetMode(PB, BIT3, GPIO_MODE_INPUT);
000002  2200              MOVS     r2,#0
000004  2108              MOVS     r1,#8
000006  4802              LDR      r0,|L4.16|
000008  f7fffffe          BL       GPIO_SetMode
;;;157    
;;;158    //    /* Enable interrupt de-bounce function and select de-bounce sampling cycle time is 1024 clocks of LIRC clock */
;;;159    //    GPIO_SET_DEBOUNCE_TIME(GPIO_DBCTL_DBCLKSRC_LIRC, GPIO_DBCTL_DBCLKSEL_8192);
;;;160    //    GPIO_ENABLE_DEBOUNCE(PB, BIT3);	
;;;161    }
00000c  bd10              POP      {r4,pc}
;;;162    
                          ENDP

00000e  0000              DCW      0x0000
                  |L4.16|
                          DCD      0x40004040

                          AREA ||i.GPIO_Wakeup_Init||, CODE, READONLY, ALIGN=2

                  GPIO_Wakeup_Init PROC
;;;162    
;;;163    void GPIO_Wakeup_Init (void)		// PA7/PC3 , to wake up MCU
000000  b570              PUSH     {r4-r6,lr}
;;;164    {
;;;165    
;;;166        GPIO_SetMode(PA, BIT7, GPIO_MODE_INPUT);
000002  4e15              LDR      r6,|L5.88|
000004  2200              MOVS     r2,#0
000006  2180              MOVS     r1,#0x80
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       GPIO_SetMode
;;;167        GPIO_EnableInt(PA, 7, GPIO_INT_FALLING);
00000e  2201              MOVS     r2,#1
000010  2107              MOVS     r1,#7
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       GPIO_EnableInt
;;;168        NVIC_EnableIRQ(GPIO_PAPBPGPH_IRQn);
000018  2004              MOVS     r0,#4
00001a  f7fffffe          BL       NVIC_EnableIRQ
;;;169    
;;;170        /* Enable interrupt de-bounce function and select de-bounce sampling cycle time is 1024 clocks of LIRC clock */
;;;171        GPIO_SET_DEBOUNCE_TIME(GPIO_DBCTL_DBCLKSRC_LIRC, GPIO_DBCTL_DBCLKSEL_2048);
00001e  4d0f              LDR      r5,|L5.92|
000020  243b              MOVS     r4,#0x3b
000022  602c              STR      r4,[r5,#0]
;;;172        GPIO_ENABLE_DEBOUNCE(PA, BIT7);
000024  6970              LDR      r0,[r6,#0x14]
000026  2180              MOVS     r1,#0x80
000028  4308              ORRS     r0,r0,r1
00002a  6170              STR      r0,[r6,#0x14]
;;;173    
;;;174        GPIO_SetMode(PC, BIT3, GPIO_MODE_INPUT);
00002c  4e0a              LDR      r6,|L5.88|
00002e  2200              MOVS     r2,#0
000030  3680              ADDS     r6,r6,#0x80
000032  2108              MOVS     r1,#8
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       GPIO_SetMode
;;;175        GPIO_EnableInt(PC, 3, GPIO_INT_FALLING);
00003a  2201              MOVS     r2,#1
00003c  2103              MOVS     r1,#3
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       GPIO_EnableInt
;;;176        NVIC_EnableIRQ(GPIO_PCPDPEPF_IRQn);
000044  2005              MOVS     r0,#5
000046  f7fffffe          BL       NVIC_EnableIRQ
;;;177    
;;;178        /* Enable interrupt de-bounce function and select de-bounce sampling cycle time is 1024 clocks of LIRC clock */
;;;179        GPIO_SET_DEBOUNCE_TIME(GPIO_DBCTL_DBCLKSRC_LIRC, GPIO_DBCTL_DBCLKSEL_2048);
00004a  602c              STR      r4,[r5,#0]
;;;180        GPIO_ENABLE_DEBOUNCE(PC, BIT3);
00004c  6970              LDR      r0,[r6,#0x14]
00004e  2108              MOVS     r1,#8
000050  4308              ORRS     r0,r0,r1
000052  6170              STR      r0,[r6,#0x14]
;;;181    	
;;;182    }
000054  bd70              POP      {r4-r6,pc}
;;;183    
                          ENDP

000056  0000              DCW      0x0000
                  |L5.88|
                          DCD      0x40004000
                  |L5.92|
                          DCD      0x40004440

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_EnableIRQ PROC
;;;628     */
;;;629    __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  06c1              LSLS     r1,r0,#27
;;;630    {
;;;631      NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000002  0ec9              LSRS     r1,r1,#27
000004  2001              MOVS     r0,#1
000006  4088              LSLS     r0,r0,r1
000008  4901              LDR      r1,|L6.16|
00000a  6008              STR      r0,[r1,#0]
;;;632    }
00000c  4770              BX       lr
;;;633    
                          ENDP

00000e  0000              DCW      0x0000
                  |L6.16|
                          DCD      0xe000e100

                          AREA ||i.NVIC_SystemReset||, CODE, READONLY, ALIGN=2

                  NVIC_SystemReset PROC
;;;729     */
;;;730    __STATIC_INLINE void NVIC_SystemReset(void)
000000  f3bf8f4f          DSB      
;;;731    {
;;;732      __DSB();                                                          /* Ensure all outstanding memory accesses included
;;;733                                                                           buffered write are completed before reset */
;;;734      SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
000004  4904              LDR      r1,|L7.24|
000006  4803              LDR      r0,|L7.20|
000008  60c8              STR      r0,[r1,#0xc]
;;;735                     SCB_AIRCR_SYSRESETREQ_Msk);
;;;736      __DSB();                                                          /* Ensure completion of memory access */
00000a  f3bf8f4f          DSB      
                  |L7.14|
;;;737    
;;;738      for(;;)                                                           /* wait until reset */
;;;739      {
;;;740        __NOP();
00000e  bf00              NOP      
000010  e7fd              B        |L7.14|
;;;741      }
;;;742    }
;;;743    
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      0x05fa0004
                  |L7.24|
                          DCD      0xe000ed00

                          AREA ||i.SYS_Disable_AnalogPORCircuit||, CODE, READONLY, ALIGN=2

                  SYS_Disable_AnalogPORCircuit PROC
;;;70     
;;;71     void SYS_Disable_AnalogPORCircuit(void)
000000  4902              LDR      r1,|L8.12|
;;;72     {
;;;73         SYS->PORDISAN = 0x5AA5;
000002  4801              LDR      r0,|L8.8|
000004  62c8              STR      r0,[r1,#0x2c]
;;;74     }
000006  4770              BX       lr
;;;75     
                          ENDP

                  |L8.8|
                          DCD      0x00005aa5
                  |L8.12|
                          DCD      0x400001c0

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;321    
;;;322    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  4c1c              LDR      r4,|L9.120|
000006  2216              MOVS     r2,#0x16
000008  2188              MOVS     r1,#0x88
                  |L9.10|
00000a  6020              STR      r0,[r4,#0]
00000c  6022              STR      r2,[r4,#0]
00000e  6021              STR      r1,[r4,#0]
000010  6823              LDR      r3,[r4,#0]
000012  2b00              CMP      r3,#0
000014  d0f9              BEQ      |L9.10|
;;;323    {
;;;324        /* Unlock protected registers */
;;;325        SYS_UnlockReg();
;;;326    
;;;327        /* Enable HIRC clock (Internal RC 48MHz) */
;;;328        CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
000016  2004              MOVS     r0,#4
000018  f7fffffe          BL       CLK_EnableXtalRC
;;;329    //    CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
;;;330    	
;;;331        /* Wait for HIRC clock ready */
;;;332        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00001c  2010              MOVS     r0,#0x10
00001e  f7fffffe          BL       CLK_WaitClockReady
;;;333    //    CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;334    
;;;335        CLK_EnableXtalRC(CLK_PWRCTL_LIRCEN_Msk);
000022  2008              MOVS     r0,#8
000024  f7fffffe          BL       CLK_EnableXtalRC
;;;336    
;;;337        /* Waiting for LIRC clock ready */
;;;338        CLK_WaitClockReady(CLK_STATUS_LIRCSTB_Msk);
000028  2008              MOVS     r0,#8
00002a  f7fffffe          BL       CLK_WaitClockReady
;;;339    
;;;340    
;;;341        /* Select HCLK clock source as HIRC and HCLK source divider as 1 */
;;;342        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
00002e  2100              MOVS     r1,#0
000030  2007              MOVS     r0,#7
000032  f7fffffe          BL       CLK_SetHCLK
;;;343    
;;;344        /* Enable UART0 clock */
;;;345        CLK_EnableModuleClock(UART0_MODULE);
000036  4d11              LDR      r5,|L9.124|
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       CLK_EnableModuleClock
;;;346        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_PCLK0, CLK_CLKDIV0_UART0(1));
00003e  2101              MOVS     r1,#1
000040  2200              MOVS     r2,#0
000042  0689              LSLS     r1,r1,#26
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       CLK_SetModuleClock
;;;347    	
;;;348        CLK_EnableModuleClock(TMR3_MODULE);
00004a  4d0d              LDR      r5,|L9.128|
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       CLK_EnableModuleClock
;;;349        CLK_SetModuleClock(TMR3_MODULE, CLK_CLKSEL1_TMR3SEL_LIRC, 0);
000052  2200              MOVS     r2,#0
000054  0529              LSLS     r1,r5,#20
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       CLK_SetModuleClock
;;;350    //   CLK_SetModuleClock(TMR3_MODULE, CLK_CLKSEL1_TMR3SEL_PCLK1, 0);
;;;351    
;;;352        /* Update System Core Clock */
;;;353        SystemCoreClockUpdate();
00005c  f7fffffe          BL       SystemCoreClockUpdate
;;;354    
;;;355        /* Set PB multi-function pins for UART0 RXD=PB.12 and TXD=PB.13 */
;;;356        SYS->GPB_MFPH = (SYS->GPB_MFPH & ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk))    |       \
000060  07a8              LSLS     r0,r5,#30
000062  6bc1              LDR      r1,[r0,#0x3c]
000064  22ff              MOVS     r2,#0xff
000066  0412              LSLS     r2,r2,#16
000068  4391              BICS     r1,r1,r2
00006a  2233              MOVS     r2,#0x33
00006c  0452              LSLS     r2,r2,#17
00006e  1889              ADDS     r1,r1,r2
000070  63c1              STR      r1,[r0,#0x3c]
000072  2000              MOVS     r0,#0
000074  6020              STR      r0,[r4,#0]
;;;357                        (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
;;;358    
;;;359        /* Lock protected registers */
;;;360        SYS_LockReg();
;;;361    }
000076  bd70              POP      {r4-r6,pc}
;;;362    
                          ENDP

                  |L9.120|
                          DCD      0x40000100
                  |L9.124|
                          DCD      0x5f803d10
                  |L9.128|
                          DCD      0x5f400005

                          AREA ||i.Software_Debounce||, CODE, READONLY, ALIGN=2

                  Software_Debounce PROC
;;;184    
;;;185    void Software_Debounce(void)
000000  b570              PUSH     {r4-r6,lr}
;;;186    {
;;;187        uint8_t reading = PB3;		// button
000002  480c              LDR      r0,|L10.52|
000004  68c0              LDR      r0,[r0,#0xc]
;;;188    
;;;189        if (reading != lastButtonState) 
000006  4d0c              LDR      r5,|L10.56|
000008  b2c4              UXTB     r4,r0                 ;187
00000a  7829              LDRB     r1,[r5,#0]  ; lastButtonState
00000c  4628              MOV      r0,r5
00000e  6880              LDR      r0,[r0,#8]
000010  428c              CMP      r4,r1
000012  d000              BEQ      |L10.22|
;;;190    	{
;;;191            // reset the debouncing timer
;;;192            lastDebounceTime = get_tick();
000014  60e8              STR      r0,[r5,#0xc]  ; lastDebounceTime
                  |L10.22|
;;;193        }
;;;194    
;;;195        if ((get_tick() - lastDebounceTime) > debounceDelay)
000016  68e9              LDR      r1,[r5,#0xc]  ; lastDebounceTime
000018  1a40              SUBS     r0,r0,r1
00001a  6929              LDR      r1,[r5,#0x10]  ; debounceDelay
00001c  4288              CMP      r0,r1
00001e  d907              BLS      |L10.48|
;;;196    	{
;;;197            if (reading != buttonState) 
000020  7868              LDRB     r0,[r5,#1]  ; buttonState
000022  4284              CMP      r4,r0
000024  d004              BEQ      |L10.48|
;;;198    		{ 
;;;199                buttonState = reading;
000026  706c              STRB     r4,[r5,#1]
;;;200    
;;;201                if (buttonState == ENABLE) 
000028  2c01              CMP      r4,#1
00002a  d101              BNE      |L10.48|
;;;202    			{
;;;203    				EntryLowPower();
00002c  f7fffffe          BL       EntryLowPower
                  |L10.48|
;;;204                }
;;;205            }
;;;206        }
;;;207    
;;;208        lastButtonState = reading;
000030  702c              STRB     r4,[r5,#0]
;;;209    
;;;210    }
000032  bd70              POP      {r4-r6,pc}
;;;211    
                          ENDP

                  |L10.52|
                          DCD      0x40004840
                  |L10.56|
                          DCD      ||.data||

                          AREA ||i.TIMER3_Init||, CODE, READONLY, ALIGN=2

                  TIMER3_Init PROC
;;;244    
;;;245    void TIMER3_Init(void)
000000  b510              PUSH     {r4,lr}
;;;246    {
;;;247        TIMER_Open(TIMER3, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L11.44|
000004  227d              MOVS     r2,#0x7d
000006  2101              MOVS     r1,#1
000008  00d2              LSLS     r2,r2,#3
00000a  06c9              LSLS     r1,r1,#27
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  0621              LSLS     r1,r4,#24
000016  4308              ORRS     r0,r0,r1
000018  6020              STR      r0,[r4,#0]
;;;248        TIMER_EnableInt(TIMER3);
;;;249        NVIC_EnableIRQ(TMR3_IRQn);	
00001a  200b              MOVS     r0,#0xb
00001c  f7fffffe          BL       NVIC_EnableIRQ
000020  6820              LDR      r0,[r4,#0]
000022  0661              LSLS     r1,r4,#25
000024  4308              ORRS     r0,r0,r1
000026  6020              STR      r0,[r4,#0]
;;;250        TIMER_Start(TIMER3);
;;;251    }
000028  bd10              POP      {r4,pc}
;;;252    
                          ENDP

00002a  0000              DCW      0x0000
                  |L11.44|
                          DCD      0x40051020

                          AREA ||i.TMR3_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  TMR3_IRQHandler PROC
;;;211    
;;;212    void TMR3_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
000002  4914              LDR      r1,|L12.84|
000004  6888              LDR      r0,[r1,#8]
000006  07c0              LSLS     r0,r0,#31
000008  0fc0              LSRS     r0,r0,#31
;;;213    {
00000a  d022              BEQ      |L12.82|
00000c  2401              MOVS     r4,#1
00000e  608c              STR      r4,[r1,#8]
;;;214    	static uint32_t LOG = 0;
;;;215    	static uint16_t CNT = 0;
;;;216    	
;;;217        if(TIMER_GetIntFlag(TIMER3) == 1)
;;;218        {
;;;219            TIMER_ClearIntFlag(TIMER3);
;;;220    
;;;221    		tick_counter();
000010  f7fffffe          BL       tick_counter
;;;222    
;;;223    		if (is_flag_set(flag_EnableLED))
000014  4910              LDR      r1,|L12.88|
000016  6848              LDR      r0,[r1,#4]  ; BitFlag
000018  2200              MOVS     r2,#0
00001a  07c0              LSLS     r0,r0,#31
00001c  2800              CMP      r0,#0
;;;224    		{
;;;225    			if (CNT++ >= 1000)
;;;226    			{		
;;;227    				CNT = 0;
;;;228    				PB14 ^= 1;
00001e  4d0f              LDR      r5,|L12.92|
;;;229    			}
;;;230    		}
;;;231    		else
;;;232    		{	
;;;233    			if (CNT++ >= 250)
000020  8848              LDRH     r0,[r1,#2]  ; CNT
000022  d007              BEQ      |L12.52|
000024  1c43              ADDS     r3,r0,#1              ;225
000026  804b              STRH     r3,[r1,#2]            ;225
000028  237d              MOVS     r3,#0x7d              ;225
00002a  00db              LSLS     r3,r3,#3              ;225
00002c  4298              CMP      r0,r3                 ;225
00002e  d310              BCC      |L12.82|
000030  804a              STRH     r2,[r1,#2]            ;227
000032  e00b              B        |L12.76|
                  |L12.52|
000034  1c43              ADDS     r3,r0,#1
000036  804b              STRH     r3,[r1,#2]
000038  28fa              CMP      r0,#0xfa
00003a  d30a              BCC      |L12.82|
;;;234    			{		
;;;235    				CNT = 0;
00003c  804a              STRH     r2,[r1,#2]
;;;236    	        	printf("%s : %4d\r\n",__FUNCTION__,LOG++);
00003e  694a              LDR      r2,[r1,#0x14]  ; LOG
000040  1c50              ADDS     r0,r2,#1
000042  6148              STR      r0,[r1,#0x14]  ; LOG
000044  4906              LDR      r1,|L12.96|
000046  a007              ADR      r0,|L12.100|
000048  f7fffffe          BL       __2printf
                  |L12.76|
00004c  6ba8              LDR      r0,[r5,#0x38]         ;228
00004e  4060              EORS     r0,r0,r4              ;228
000050  63a8              STR      r0,[r5,#0x38]         ;228
                  |L12.82|
;;;237    				PB14 ^= 1;
;;;238    
;;;239    			}
;;;240    		}
;;;241        }
;;;242    }
000052  bd70              POP      {r4-r6,pc}
;;;243    
                          ENDP

                  |L12.84|
                          DCD      0x40051020
                  |L12.88|
                          DCD      ||.data||
                  |L12.92|
                          DCD      0x40004840
                  |L12.96|
                          DCD      ||.constdata||+0xe
                  |L12.100|
000064  2573203a          DCB      "%s : %4d\r\n",0
000068  20253464
00006c  0d0a00  
00006f  00                DCB      0

                          AREA ||i.UART02_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART02_IRQHandler PROC
;;;280    
;;;281    void UART02_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;282    {
;;;283        if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RDAINT_Msk | UART_INTSTS_RXTOINT_Msk))     /* UART receive data available flag */
000002  4c0b              LDR      r4,|L13.48|
000004  69e0              LDR      r0,[r4,#0x1c]
000006  2111              MOVS     r1,#0x11
000008  0209              LSLS     r1,r1,#8
00000a  4208              TST      r0,r1
00000c  d102              BNE      |L13.20|
00000e  e004              B        |L13.26|
                  |L13.16|
;;;284        {
;;;285            while(UART_GET_RX_EMPTY(UART0) == 0)
;;;286            {
;;;287                UARTx_Process();
000010  f7fffffe          BL       UARTx_Process
                  |L13.20|
000014  69a1              LDR      r1,[r4,#0x18]         ;285
000016  0449              LSLS     r1,r1,#17             ;285
000018  d5fa              BPL      |L13.16|
                  |L13.26|
;;;288            }
;;;289        }
;;;290    
;;;291        if(UART0->FIFOSTS & (UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk | UART_FIFOSTS_RXOVIF_Msk))
00001a  69a1              LDR      r1,[r4,#0x18]
00001c  4620              MOV      r0,r4
00001e  2271              MOVS     r2,#0x71
000020  4211              TST      r1,r2
000022  d003              BEQ      |L13.44|
;;;292        {
;;;293            UART_ClearIntFlag(UART0, (UART_INTSTS_RLSINT_Msk| UART_INTSTS_BUFERRINT_Msk));
000024  2109              MOVS     r1,#9
000026  0289              LSLS     r1,r1,#10
000028  f7fffffe          BL       UART_ClearIntFlag
                  |L13.44|
;;;294        }
;;;295    }
00002c  bd10              POP      {r4,pc}
;;;296    
                          ENDP

00002e  0000              DCW      0x0000
                  |L13.48|
                          DCD      0x40070000

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;296    
;;;297    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;298    {
;;;299        SYS_ResetModule(UART0_RST);
000002  481d              LDR      r0,|L14.120|
000004  f7fffffe          BL       SYS_ResetModule
;;;300    
;;;301        /* Configure UART0 and set UART0 baud rate */
;;;302        UART_Open(UART0, 115200);
000008  4c1c              LDR      r4,|L14.124|
00000a  21e1              MOVS     r1,#0xe1
00000c  0249              LSLS     r1,r1,#9
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;303    
;;;304    	/* Set UART receive time-out */
;;;305    	UART_SetTimeoutCnt(UART0, 20);
000014  2114              MOVS     r1,#0x14
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;306    
;;;307    	UART0->FIFO &= ~UART_FIFO_RFITL_4BYTES;
00001c  68a0              LDR      r0,[r4,#8]
00001e  2110              MOVS     r1,#0x10
000020  4388              BICS     r0,r0,r1
000022  60a0              STR      r0,[r4,#8]
;;;308    	UART0->FIFO |= UART_FIFO_RFITL_8BYTES;
000024  68a0              LDR      r0,[r4,#8]
000026  2120              MOVS     r1,#0x20
000028  4308              ORRS     r0,r0,r1
00002a  60a0              STR      r0,[r4,#8]
;;;309    
;;;310    	/* Enable UART Interrupt - */
;;;311    	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_TOCNTEN_Msk | UART_INTEN_RXTOIEN_Msk);
00002c  6860              LDR      r0,[r4,#4]
00002e  4914              LDR      r1,|L14.128|
000030  4308              ORRS     r0,r0,r1
000032  6060              STR      r0,[r4,#4]
;;;312    	
;;;313    	NVIC_EnableIRQ(UART02_IRQn);
000034  200c              MOVS     r0,#0xc
000036  f7fffffe          BL       NVIC_EnableIRQ
;;;314    
;;;315    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00003a  f7fffffe          BL       CLK_GetCPUFreq
00003e  4601              MOV      r1,r0
000040  a010              ADR      r0,|L14.132|
000042  f7fffffe          BL       __2printf
;;;316    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
000046  f7fffffe          BL       CLK_GetHXTFreq
00004a  4601              MOV      r1,r0
00004c  a014              ADR      r0,|L14.160|
00004e  f7fffffe          BL       __2printf
;;;317    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000052  f7fffffe          BL       CLK_GetLXTFreq
000056  4601              MOV      r1,r0
000058  a017              ADR      r0,|L14.184|
00005a  f7fffffe          BL       __2printf
;;;318    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
00005e  f7fffffe          BL       CLK_GetPCLK0Freq
000062  4601              MOV      r1,r0
000064  a01a              ADR      r0,|L14.208|
000066  f7fffffe          BL       __2printf
;;;319    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());	
00006a  f7fffffe          BL       CLK_GetPCLK1Freq
00006e  4601              MOV      r1,r0
000070  a01e              ADR      r0,|L14.236|
000072  f7fffffe          BL       __2printf
;;;320    }
000076  bd10              POP      {r4,pc}
;;;321    
                          ENDP

                  |L14.120|
                          DCD      0x04000010
                  |L14.124|
                          DCD      0x40070000
                  |L14.128|
                          DCD      0x00000811
                  |L14.132|
000084  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000088  4b5f4765
00008c  74435055
000090  46726571
000094  203a2025
000098  38640d0a
00009c  00      
00009d  00                DCB      0
00009e  00                DCB      0
00009f  00                DCB      0
                  |L14.160|
0000a0  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
0000a4  47657448
0000a8  58544672
0000ac  6571203a
0000b0  20253864
0000b4  0d0a00  
0000b7  00                DCB      0
                  |L14.184|
0000b8  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000bc  4765744c
0000c0  58544672
0000c4  6571203a
0000c8  20253864
0000cc  0d0a00  
0000cf  00                DCB      0
                  |L14.208|
0000d0  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000d4  47657450
0000d8  434c4b30
0000dc  46726571
0000e0  203a2025
0000e4  38640d0a
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L14.236|
0000ec  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000f0  47657450
0000f4  434c4b31
0000f8  46726571
0000fc  203a2025
000100  38640d0a
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0

                          AREA ||i.UARTx_Process||, CODE, READONLY, ALIGN=2

                  UARTx_Process PROC
;;;253    
;;;254    void UARTx_Process(void)
000000  b510              PUSH     {r4,lr}
;;;255    {
;;;256    	uint8_t res = 0;
;;;257    	
;;;258    	res = UART_READ(UART0);
000002  4809              LDR      r0,|L15.40|
000004  6800              LDR      r0,[r0,#0]
000006  b2c0              UXTB     r0,r0
;;;259    
;;;260    	if (res == 'x' || res == 'X')
000008  2878              CMP      r0,#0x78
00000a  d00b              BEQ      |L15.36|
00000c  2858              CMP      r0,#0x58
00000e  d009              BEQ      |L15.36|
;;;261    	{
;;;262    		NVIC_SystemReset();
;;;263    	}
;;;264    
;;;265    	if (res > 0x7F)
000010  287f              CMP      r0,#0x7f
000012  d903              BLS      |L15.28|
;;;266    	{
;;;267    		printf("invalid command\r\n");
000014  a005              ADR      r0,|L15.44|
000016  f7fffffe          BL       __2printf
                  |L15.26|
;;;268    	}
;;;269    	else
;;;270    	{
;;;271    		switch(res)
;;;272    		{
;;;273    			case 'Z':
;;;274    			case 'z':				
;;;275    				NVIC_SystemReset();
;;;276    				break;				
;;;277    		}
;;;278    	}
;;;279    }
00001a  bd10              POP      {r4,pc}
                  |L15.28|
00001c  285a              CMP      r0,#0x5a              ;271
00001e  d001              BEQ      |L15.36|
000020  287a              CMP      r0,#0x7a              ;271
000022  d1fa              BNE      |L15.26|
                  |L15.36|
000024  f7fffffe          BL       NVIC_SystemReset
;;;280    
                          ENDP

                  |L15.40|
                          DCD      0x40070000
                  |L15.44|
00002c  696e7661          DCB      "invalid command\r\n",0
000030  6c696420
000034  636f6d6d
000038  616e640d
00003c  0a00    
00003e  00                DCB      0
00003f  00                DCB      0

                          AREA ||i.convertDecToBin||, CODE, READONLY, ALIGN=2

                  convertDecToBin PROC
;;;39     
;;;40     void convertDecToBin(int n)
000000  b5f1              PUSH     {r0,r4-r7,lr}
;;;41     {
000002  b082              SUB      sp,sp,#8
;;;42         int k = 0;
000004  2500              MOVS     r5,#0
;;;43         unsigned char *p = (unsigned char*)&n;
000006  a802              ADD      r0,sp,#8
;;;44         int val2 = 0;
;;;45         int i = 0;
;;;46         for(k = 0; k <= 1; k++)
;;;47         {
;;;48             val2 = *(p+k);
;;;49             for (i = 7; i >= 0; i--)
;;;50             {
;;;51                 if(val2 & (1 << i))
000008  2701              MOVS     r7,#1
00000a  9000              STR      r0,[sp,#0]
                  |L16.12|
00000c  9800              LDR      r0,[sp,#0]            ;48
00000e  2407              MOVS     r4,#7                 ;49
000010  5d46              LDRB     r6,[r0,r5]            ;48
                  |L16.18|
000012  4638              MOV      r0,r7
000014  40a0              LSLS     r0,r0,r4
000016  4230              TST      r0,r6
000018  d001              BEQ      |L16.30|
;;;52                     printf("1");
00001a  a007              ADR      r0,|L16.56|
00001c  e000              B        |L16.32|
                  |L16.30|
;;;53                 else
;;;54                     printf("0");
00001e  a007              ADR      r0,|L16.60|
                  |L16.32|
000020  f7fffffe          BL       __2printf
000024  1e64              SUBS     r4,r4,#1
000026  d5f4              BPL      |L16.18|
;;;55             }
;;;56             printf(" ");
000028  a005              ADR      r0,|L16.64|
00002a  f7fffffe          BL       __2printf
00002e  1c6d              ADDS     r5,r5,#1
000030  2d01              CMP      r5,#1                 ;46
000032  ddeb              BLE      |L16.12|
;;;57         }
;;;58     }
000034  bdfe              POP      {r1-r7,pc}
;;;59     
                          ENDP

000036  0000              DCW      0x0000
                  |L16.56|
000038  3100              DCB      "1",0
00003a  00                DCB      0
00003b  00                DCB      0
                  |L16.60|
00003c  3000              DCB      "0",0
00003e  00                DCB      0
00003f  00                DCB      0
                  |L16.64|
000040  2000              DCB      " ",0
000042  00                DCB      0
000043  00                DCB      0

                          AREA ||i.get_tick||, CODE, READONLY, ALIGN=2

                  get_tick PROC
;;;65     
;;;66     uint32_t get_tick(void)
000000  4801              LDR      r0,|L17.8|
;;;67     {
;;;68     	return (conter_tick);
000002  6880              LDR      r0,[r0,#8]  ; conter_tick
;;;69     }
000004  4770              BX       lr
;;;70     
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      ||.data||

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;370    
;;;371    int main()
000000  f7fffffe          BL       SYS_Init
;;;372    {
;;;373    
;;;374        SYS_Init();
;;;375    
;;;376        UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;377    
;;;378        GPIO_SetMode(PB, BIT14, GPIO_MODE_OUTPUT);
000008  2201              MOVS     r2,#1
00000a  0391              LSLS     r1,r2,#14
00000c  4805              LDR      r0,|L18.36|
00000e  f7fffffe          BL       GPIO_SetMode
;;;379    	GPIO_Power_Init();
000012  f7fffffe          BL       GPIO_Power_Init
;;;380    	GPIO_Wakeup_Init();
000016  f7fffffe          BL       GPIO_Wakeup_Init
;;;381    
;;;382    	TIMER3_Init();
00001a  f7fffffe          BL       TIMER3_Init
                  |L18.30|
;;;383    
;;;384        /* Got no where to go, just loop forever */
;;;385        while(1)
;;;386        {
;;;387    		Software_Debounce();
00001e  f7fffffe          BL       Software_Debounce
000022  e7fc              B        |L18.30|
;;;388    
;;;389        }
;;;390    }
;;;391    
                          ENDP

                  |L18.36|
                          DCD      0x40004040

                          AREA ||i.tick_counter||, CODE, READONLY, ALIGN=2

                  tick_counter PROC
;;;60     
;;;61     void tick_counter(void)
000000  4802              LDR      r0,|L19.12|
;;;62     {
;;;63     	conter_tick++;
000002  6881              LDR      r1,[r0,#8]  ; conter_tick
000004  1c49              ADDS     r1,r1,#1
000006  6081              STR      r1,[r0,#8]  ; conter_tick
;;;64     }
000008  4770              BX       lr
;;;65     
                          ENDP

00000a  0000              DCW      0x0000
                  |L19.12|
                          DCD      ||.data||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  456e7472          DCB      0x45,0x6e,0x74,0x72
000004  794c6f77          DCB      0x79,0x4c,0x6f,0x77
000008  506f7765          DCB      0x50,0x6f,0x77,0x65
00000c  7200              DCB      0x72,0x00
                  |symbol_number.63|
00000e  544d              DCB      0x54,0x4d
000010  52335f49          DCB      0x52,0x33,0x5f,0x49
000014  52514861          DCB      0x52,0x51,0x48,0x61
000018  6e646c65          DCB      0x6e,0x64,0x6c,0x65
00001c  7200              DCB      0x72,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  lastButtonState
000000  00                DCB      0x00
                  buttonState
000001  00                DCB      0x00
                  ||CNT||
000002  0000              DCW      0x0000
                  BitFlag
                          DCD      0x00000000
                  conter_tick
                          DCD      0x00000000
                  lastDebounceTime
                          DCD      0x00000000
                  debounceDelay
                          DCD      0x00000032
                  LOG
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_BitFlag____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REVSH|
#line 402
|__asm___6_main_c_BitFlag____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
